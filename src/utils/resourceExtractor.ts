
/**
 * Utility functions for extracting content from URLs and generating summaries
 */

/**
 * Extract content and metadata from a URL
 * @param url The URL to extract content from
 * @returns Promise with extracted content and metadata
 */
export const extractContentFromUrl = async (url: string): Promise<{
  title: string;
  description: string;
  content: string;
  tags: string[];
}> => {
  try {
    // Simulate API call to a web scraping service
    // In a real implementation, this would call an actual service
    console.log(`Extracting content from ${url}`);
    
    // Parse domain for info
    const domain = new URL(url).hostname;
    let title = `Resource from ${domain}`;
    let description = `Content extracted from ${url}`;
    let content = "The extracted content would appear here in a real implementation.";
    let tags: string[] = [];
    
    // Simple domain-based tag extraction
    if (domain.includes('github')) {
      tags.push('github', 'code-repository');
      title = `GitHub Repository: ${domain.split('.')[0]}`;
    } else if (domain.includes('react')) {
      tags.push('react', 'frontend', 'javascript');
      title = "React Documentation";
      description = "Official React.js documentation and guides";
    } else if (domain.includes('tailwind')) {
      tags.push('tailwindcss', 'css', 'styling');
      title = "Tailwind CSS Documentation";
      description = "Utility-first CSS framework documentation";
    } else if (domain.includes('typescript')) {
      tags.push('typescript', 'javascript', 'language');
      title = "TypeScript Documentation";
      description = "TypeScript language documentation and guides";
    } else if (domain.includes('aws') || domain.includes('azure') || domain.includes('gcp')) {
      tags.push('cloud', 'infrastructure', 'deployment');
      title = `Cloud Provider: ${domain.split('.')[0].toUpperCase()}`;
      description = "Cloud infrastructure documentation";
    } else {
      // Extract domain-based tags
      tags = domain.split('.')
        .filter(part => part !== 'www' && part !== 'com' && part !== 'org' && part !== 'io' && part.length > 2)
        .map(part => part.toLowerCase());
    }
    
    return { title, description, content, tags };
  } catch (error) {
    console.error('Error extracting content from URL:', error);
    throw new Error('Failed to extract content from URL');
  }
};

/**
 * Generate an AI summary of content
 * @param content The content to summarize
 * @param maxLength Maximum length of the summary
 * @returns Promise with the generated summary
 */
export const generateAISummary = async (content: string, maxLength: number = 200): Promise<string> => {
  try {
    // In a real implementation, this would call an LLM API
    console.log(`Generating summary of content (max length: ${maxLength})`);
    
    // Simulate summary generation
    let summary = "This is an AI-generated summary of the resource content. ";
    summary += "It would highlight key points, main topics, and relevant information. ";
    summary += "In a real implementation, this would be generated by an LLM with the actual content.";
    
    // Ensure summary doesn't exceed max length
    if (summary.length > maxLength) {
      summary = summary.substring(0, maxLength - 3) + "...";
    }
    
    return summary;
  } catch (error) {
    console.error('Error generating AI summary:', error);
    return "Failed to generate summary. Please try again later.";
  }
};

/**
 * Calculate relevance score for a resource against a query
 * @param resource The resource to score
 * @param query The query to score against
 * @returns A relevance score between 0 and 1
 */
export const calculateRelevanceScore = (
  resource: { 
    title: string;
    description: string;
    tags?: string[];
    content?: string;
  }, 
  query: string
): number => {
  // Simple relevance scoring using string matching
  // In a real implementation, this would use more sophisticated techniques
  const queryTerms = query.toLowerCase().split(/\s+/);
  const textToMatch = [
    resource.title.toLowerCase(),
    resource.description.toLowerCase(),
    ...(resource.tags || []).map(tag => tag.toLowerCase()),
    (resource.content || "").toLowerCase().substring(0, 1000) // Limit content length
  ].join(" ");
  
  let score = 0;
  const maxScore = queryTerms.length;
  
  // Score based on term presence
  for (const term of queryTerms) {
    if (term.length > 2 && textToMatch.includes(term)) {
      // Title matches are weighted higher
      if (resource.title.toLowerCase().includes(term)) {
        score += 0.5;
      }
      // Tag matches are also weighted higher
      if (resource.tags?.some(tag => tag.toLowerCase().includes(term))) {
        score += 0.3;
      }
      score += 0.2;
    }
  }
  
  // Normalize score between 0 and 1
  return Math.min(score / Math.max(1, maxScore), 1);
};
